# **Linux-Shell-Scripting.**

# **Chapter 3: Shells (bash) structured Language Constructs.**

- Decision making
- Loops

Is there any difference making decision in Real life and with Computers? Well real life decision are quite
complicated to all of us and computers even don't have that much power to understand our real life
decisions. What computer know is 0 (zero) and 1 that is Yes or No. To make this idea clear, lets checkout with bc - Linux calculator program.

### #bc

After this command bc is started and waiting for your commands, i.e. give it some calculation as follows

type 5 + 2 as:

5 + 2

7

7 is response of bc i.e. addition of 5 + 2 you can even try

5 - 2

5 / 2

See what happened if you type 5 > 2 as follows

5 > 2

1

1 (One?) is response of bc, How? bc compare 5 with 2 as, Is 5 is greater then 2, (If I ask same question to you, your answer will be YES), bc gives this 'YES' answer by showing 1 value. Now try

5 < 2

0

0 (Zero) indicates the false i.e. Is 5 is less than 2?, Your answer will be no which is indicated by bc by showing 0 (Zero). Remember in bc, relational expression always returns true (1) or false (0 - zero).


It means when ever there is any type of comparison in Linux Shell It gives only two answer one is YES and NO is other.

Linux shell value = Zero(0) = Yes/True

Linux shell value = Non-Zero = No/False

- # **if condition**

if condition which is used for decision making in shell script, If given condition is true then command1 is executed.

	if condition
	then
		command1 if condition is true or if exit status
		of condition is 0 (Zero)
	fi..



Condition is defined as:
"Condition is nothing but comparison between two values."

For compression you can use test or [ expr ] statements or even exist status can be also used.

Expression is defined as:
"An expression is nothing but combination of values, relational operator (such as >,<, <> etc) and
mathematical operators (such as +, -, / etc )."

Following are all examples of expression:

5 > 2

3 + 6

3 * 65

a < b

c > 5

c > 5 + 30 -1

Write shell script as:

![Screen Shot 2021-01-27 at 11.57.35 PM.png]({{site.baseurl}}/Screen Shot 2021-01-27 at 11.57.35 PM.png)

Run above script as:


![Screen Shot 2021-01-28 at 12.00.40 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.00.40 AM.png)

Shell script name is showfile ($0) and nilesh is argument (which is $1).Then shell compare it as follows:

if cat $1 which is expanded to if cat foo.

### **Exercise**

Write shell script as follows:

![Screen Shot 2021-01-28 at 12.06.32 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.06.32 AM.png)

Run above script as:

![Screen Shot 2021-01-28 at 12.07.17 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.07.17 AM.png)

### **Answer the following question in referance to above script:**

(A) foo file exists on your disk and you give command, $ ./rmfi foo what will be output?

(B) If bar file not present on your disk and you give command, $ ./rmfi bar what will be output?

(C) And if you type $ ./rmfi What will be output?


#### **Answers**

(A)

![Screen Shot 2021-01-28 at 12.09.01 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.09.01 AM.png)

(B)

![Screen Shot 2021-01-28 at 12.09.40 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.09.40 AM.png)

(C)

![Screen Shot 2021-01-28 at 12.10.55 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.10.55 AM.png)


- # **test command or [ expr ]**

test command or [ expr ] is used to see if an expression is true, and if it is true it return zero(0), otherwise returns nonzero for false.

Syntax:
test expression OR [ expression ]

### **Following script determine whether given argument number is positive.**

![Screen Shot 2021-01-28 at 12.17.17 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.17.17 AM.png)

Run it as follows:

![Screen Shot 2021-01-28 at 12.21.19 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.21.19 AM.png)

- Detailed explanation
The line, if test $1 -gt 0 , test to see if first command line argument($1) is greater than 0. If it is true(0) then test will return 0 and output will printed as 5 number is positive but for -45 argument there is no output because our condition is not true(0) (no -45 is not greater than 0) hence echo statement is skipped.
And for last statement we have not supplied any argument hence error ./ispostive: test: -gt: unary
operator expected, is generated by shell , to avoid such error we can test whether command line argument is supplied or not.

- test or [ expr ] works with

1.Integer ( Number without decimal point)

2.File types

3.Character strings

### **NOTE: == is equal, != is not equal.**

-eq = is equal to. 

-ne = is not equal to.

-lt = is less than.

-le = is less than or equal to.

-gt = greater than

-ge = is greater than or equal to.


string1 = string2 = string1 is equal to string2

string != string2 = string1 is NOT equal to string2

string1           = string1 is NOT NULL or not defined 

-n string1        = string1 is NOT NULL and does exist

-z string1        = string1 is NULL and does exist


! expression      = Logical NOT

expression1 -a expression2 = Logical AND

expression1 -o expression2 = Logical OR

- # **if...else...fi**

If given condition is true then command1 is executed otherwise command2 is executed.

Syntax:

	if condition
    then
    	condition is zero (true - 0)
        execute all commands upto else statement
	else
    	if condition is not true then
        execute all commands upto fi
  	fi
    
 Write Script as follows:
 
 ![Screen Shot 2021-01-28 at 12.39.52 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.39.52 AM.png)


Try it as follows:

![Screen Shot 2021-01-28 at 12.41.02 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.41.02 AM.png)

Detailed explanation:
First script checks whether command line argument is given or not, if not given then it print error message as "./ispos_n : You must give/supply one integers". if statement checks whether number of argument ($#) passed to script is not equal (-eq) to 0, if we passed any argument to script then this if statement is false and if no command line argument is given then this if statement is true. The echo command i.e.

echo "$0 : You must give/supply one integers"
| |
| |
1 2
1 will print Name of script
2 will print this error message

And finally statement exit 1 causes normal program termination with exit status 1 (nonzero means script is not successfully run).
The last sample run $ isnump_n 0 , gives output as "0 number is negative", because given argument is not > 0, hence condition is false and it's taken as negative number. To avoid this replace second if statement with if test $1 -ge 0.
    
- # **Nested if-else-fi**

You can write the entire if-else construct within either the body of the if statement of the body of an else statement. This is called the nesting of ifs.

![Screen Shot 2021-01-28 at 12.53.31 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.53.31 AM.png)

Run the above shell script as follows:

![Screen Shot 2021-01-28 at 12.55.09 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 12.55.09 AM.png)

Note that Second if-else constuct is nested in the first else statement. If the condition in the first if statement is false the the condition in the second if statement is checked. If it is false as well the final else statement is executed.

Syntax:

	if condition
		then
			if condition
		then
			.....
			..
			do this
		else
			....
			..
			do this
	fi
		else
			...
			.....
			do this
	fi

- # **Multilevel if-then-else**

Syntax:

	if condition
	then
		condition is zero (true - 0)
		execute all commands up to elif statement
	elif condition1
	then
		condition1 is zero (true - 0)
		execute all commands up to elif statement
	elif condition2
	then
		condition2 is zero (true - 0)
		execute all commands up to elif statement
	else
		None of the above condtion,condtion1,condtion2 are true (i.e.
		all of the above nonzero or false)
		execute all commands up to fi
	fi
   
For multilevel if-then-else statement try the following script:

![Screen Shot 2021-01-28 at 1.00.10 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 1.00.10 AM.png)


Try above script as follows:

![Screen Shot 2021-01-28 at 1.01.11 AM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 1.01.11 AM.png)

Above program gives error for last run, here integer comparison is expected therefore error like "./elf: [: -gt: unary operator
expected" occurs, but still our program notify this error to user by providing message "Opps! a is not number, give number".


- # **Loops in Shell Scripts**

Loop defined as:

"Computer can repeat particular instruction again and again, until particular condition satisfies. A group of instruction that is executed repeatedly is called a loop."

Bash supports:

- for loop
- while loop

Note that in each and every loop,

(a) First, the variable used in loop condition must be initialized, then execution of the loop begins.

(b) A test (condition) is made at the beginning of each iteration.

(c) The body of loop ends with a statement that modifies the value of the test (condition) variable.

### **for Loop**


	for { variable name } in { list }
	do
		execute one for each item in the list until the list is
		not finished (And repeat all statement between do and done)
	done
    
write the script as follows:

![Screen Shot 2021-01-28 at 5.54.19 PM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 5.54.19 PM.png)


Run it above script as follows:

![Screen Shot 2021-01-28 at 5.54.53 PM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 5.54.53 PM.png)


The for loop first creates i variable and assigned a number to i from the list of number from 1 to 5, The shell execute echo statement for each assignment of i. (This is usually know as iteration) This process will continue until all the items in the list were not finished, because of this it will repeat 5 echo statements.


Write a script to multiple a given number 10 times.

![Screen Shot 2021-01-28 at 5.56.33 PM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 5.56.33 PM.png)

Save above script and run it as:

![Screen Shot 2021-01-28 at 5.57.23 PM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 5.57.23 PM.png)

This happened because we have not supplied given number for which we want multiplication table, Hence script is showing Error message, Syntax and usage of our script. This is good idea if our program takes some argument, let the user know what is use of the script and how to used the script.

Note that to terminate our script we used 'exit 1' command which takes 1 as argument (1 indicates error and therefore script is terminated).

Even you can use following syntax:

	for (( expr1; expr2; expr3 ))
	do
		.....
		...
		repeat all statements between do and
		done until expr2 is TRUE
	Done

In above syntax BEFORE the first iteration, expr1 is evaluated. This is usually used to initialize variables for the loop.

All the statements between do and done is executed repeatedly UNTIL the value of expr2 is TRUE.
AFTER each iteration of the loop, expr3 is evaluated. This is usually use to increment a loop counter.

![Screen Shot 2021-01-28 at 6.05.32 PM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 6.05.32 PM.png)

Run the above script as follows:

![Screen Shot 2021-01-28 at 6.05.59 PM.png]({{site.baseurl}}/Screen Shot 2021-01-28 at 6.05.59 PM.png)

In above example, first expression (i = 0), is used to set the value variable i to zero.
Second expression is condition i.e. all statements between do and done executed as long as expression 2 (i.e continue as long as the value of variable i is less than or equel to 5) is TRUE.
Last expression i++ increments the value of i by 1 i.e. it's equivalent to i = i + 1 statement.


### **Nesting of for Loop**

The if statement can nested, similarly loop statement can be nested. You can nest the for loop. To understand the nesting of for loop see the following shell script.

![Screen Shot 2021-02-01 at 10.42.02 AM.png]({{site.baseurl}}/Screen Shot 2021-02-01 at 10.42.02 AM.png)


Run the above script as follows.

![Screen Shot 2021-02-01 at 10.42.35 AM.png]({{site.baseurl}}/Screen Shot 2021-02-01 at 10.42.35 AM.png)


Here, for each value of i the inner loop is cycled through 5 times, with the varible j taking values from 1 to 5. The inner for loop terminates when the value of j exceeds 5, and the outer loop terminets when the value of i exceeds 5.


Following script is quite intresting, it prints the chess board on screen.

![Screen Shot 2021-02-01 at 10.44.25 AM.png]({{site.baseurl}}/Screen Shot 2021-02-01 at 10.44.25 AM.png)


Run the above script as follows:

![Screen Shot 2021-02-01 at 10.45.02 AM.png]({{site.baseurl}}/Screen Shot 2021-02-01 at 10.45.02 AM.png)


Above shell script cab be explained as follows:

- **for (( i = 1; i <= 9; i++ ))** = Begin the outer loop which runs 9 times., and the outer
loop terminets when the value of i exceeds 9

- **for (( j = 1 ; j <= 9; j++ ))** = Begins the inner loop, for each value of i the inner loop is
cycled through 9 times, with the varible j taking values from 1 to 9. The inner for loop terminates when the value of j exceeds 9.

- **tot=`expr $i + $j`  
tmp=`expr $tot % 2`** = See for even and odd number positions using these
statements.

- **if [ $tmp -eq 0 ]; then**

  **echo -e -n "\033[47m "**

  **else**

  **echo -e -n "\033[40m "**

  **fi**  
  
If even number posiotion print the white colour block
(using echo -e -n "\033[47m " statement); otherwise for
odd postion print the black colour box (using echo -e -n
"\033[40m " statement). This statements are responsible to
print entier chess board on screen with alternet colours.


- **done = End of inner loop**

- **echo -e -n "\033[40m"** = Make sure its black background as we always have on our
terminals.

- **echo ""** = Print the blank line.

- **done** = End of outer loop and shell scripts get terminted by printing
the chess board.

**Exercise**

**1. Write shell script using for loop to print the following patterns on screen.**

![Screen Shot 2021-02-01 at 10.58.04 AM.png]({{site.baseurl}}/Screen Shot 2021-02-01 at 10.58.04 AM.png)


Script: 

![Screen Shot 2021-02-01 at 10.58.34 AM.png]({{site.baseurl}}/Screen Shot 2021-02-01 at 10.58.34 AM.png)

Output:

![Screen Shot 2021-02-01 at 11.01.18 AM.png]({{site.baseurl}}/Screen Shot 2021-02-01 at 11.01.18 AM.png)


**2.Write shell script using for loop to print the following patterns on screen.**

![Screen Shot 2021-02-01 at 10.59.50 AM.png]({{site.baseurl}}/Screen Shot 2021-02-01 at 10.59.50 AM.png)

Script:

![Screen Shot 2021-02-01 at 11.00.36 AM.png]({{site.baseurl}}/Screen Shot 2021-02-01 at 11.00.36 AM.png)

Output: 

![Screen Shot 2021-02-01 at 11.00.23 AM.png]({{site.baseurl}}/Screen Shot 2021-02-01 at 11.00.23 AM.png)


### **while loop**

Loop is executed as long as given condition is true.

Syntax:

	while [ condition ]
	do
		command1
		command2
		command3
		..
		....
	done

![Screen Shot 2021-02-02 at 8.53.53 AM.png]({{site.baseurl}}/Screen Shot 2021-02-02 at 8.53.53 AM.png)


Save it and try as

chmod 755 nt1

./nt1 7

Above loop can be explained as follows:

- n=$1 = Set the value of command line argument to variable n. (Here it's set to 7 )
- i=1 = Set variable i to 1
- while [ $i -le 10 ] = This is our loop condition, here if value of i is less than 10 then, shell execute all statements between do and done.
- do = Start loop.
- echo "$n * $i = `expr $i \* $n`" = Print multiplication table as 7 * 1 = 7 Here each time value of variable n is multiply be i.
- i=`expr $i + 1` = Increment i by 1 and store result to i. ( i.e. i=i+1).
- done = Loop stops here if i is not less than 10 i.e. condition of loop is not true. Hence loop is terminated.


### **The case Statement**

The case statement is good alternative to Multilevel if-then-else-fi statement. It enable you to match several values against one variable. Its easier to read and write.

Syntax:
	case $variable-name in
		pattern1) command
					...
					..
					command;;
		pattern2) command
					...
					..
					command;;
		patternN) command
					...
					..
					command;;
		*) command
					...
					..
					command;;
		esac
        
        
The $variable-name is compared against the patterns until a match is found. The shell then executes all the statements up to the two semicolons that are next to each other. The default is *) and its executed if no match is found.     


First script will check, that if $1(first command line argument) is given or not, if NOT given set value of rental variable to "*** Unknown vehicle",if command line arg is supplied/given set value of rental variable to given value (command line arg). The $rental is compared against the patterns until a match is found. For first test run its match with van and it will show output "For van Rs.10 per k/m." For second test run it print, "For car Rs.20 per k/m". And for last run, there is no match for Maruti-800, hence default i.e. *) is executed and it prints, "Sorry, I can not get a Maruti-800 for you".

![Screen Shot 2021-02-04 at 8.33.45 AM.png]({{site.baseurl}}/Screen Shot 2021-02-04 at 8.33.45 AM.png)

![Screen Shot 2021-02-04 at 8.38.34 AM.png]({{site.baseurl}}/Screen Shot 2021-02-04 at 8.38.34 AM.png)

Note that esac is always required to indicate end of case statement.


# **Chapter 4: Advanced Shell Scripting Commands.**

- Functions
- User interface
- Conditional execution
- File Descriptors
- traps
- Multiple command line args handling etc


### **/dev/null - Use to send unwanted output of program**

Syntax:	

	command > /dev/null
    
$ ls > /dev/null
Output of above command is not shown on screen its send to this special file. The /dev directory contains other device files. The files in this directory mostly represent peripheral devices such disks like floppy disk, sound card, line printers etc.


### **Local and Global Shell variable (export command)**

Normally all our variables are local. Local variable can be used in same shell, if you load another copy of shell (by typing the /bin/bash at the $ prompt) then new shell ignored all old shell's variable. For e.g. Consider following example

	$ vech=Bus
	$ echo $vech
	Bus
	$ /bin/bash
	$ echo $vech
	NOTE:-Empty line printed
	$ vech=Car
	$ echo $vech
	Car
	$ exit
	$ echo $vech
	Bus
    
- vech=Bus - Create new local variable 'vech' with Bus as value in first shell.
- echo $vech - Print the contains of variable vech
- /bin/bash - Now load second shell in memory (Which ignores all old shell's variable)
- echo $vech - Print the contains of variable vech
- vech=Car - Create new local variable 'vech' with Car as value in second shell
- echo $vech - Print the contains of variable vech
- exit - Exit from second shell return to first shell
- echo $vech - Print the contains of variable vech (Now you can see first shells variable and its value)


    
    
Global shell defined as:

"You can copy old shell's variable to new shell (i.e. first shells variable to seconds shell), such variable is know as Global Shell variable."


To set global varible you have to use export command.

	export variable1, variable2,.....variableN
    
    
	$ vech=Bus
	$ echo $vech
	Bus
	$ export vech
	$ /bin/bash
	$ echo $vech
	Bus
	$ exit
	$ echo $vech
	Bus	
    
- vech=Bus - Create new local variable 'vech' with Bus as value in first shell.
- echo $vech - Print the contains of variable vech.
- export vech - Export first shells variable to second shell i.e. global varible.
- /bin/bash - Now load second shell in memory (Old shell's variable is accessed from second shell,
if they are exported ).
- echo $vech - Print the contains of variable vech.
- exit - Exit from second shell return to first shell.
- echo $vech - Print the contains of variable vech.


### **Conditional execution i.e. && and ||**

The control operators are && (read as AND) and || (read as OR). The syntax for AND list is as follows

Syntax:

	command1 && command2

command2 is executed if, and only if, command1 returns an exit status of zero.

The syntax for OR list as follows

Syntax:

	command1 || command2

command2 is executed if and only if command1 returns a non-zero exit status.

You can use both as follows
Syntax:

- command1 && comamnd2 if exist status is zero || command3 if exit status is non-zero

if command1 is executed successfully then shell will run command2 and if command1 is not successful then command3 is executed.

Example:

- _$ rm myf && echo "File is removed successfully" || echo "File is not removed"_

If file (myf) is removed successful (exist status is zero) then "echo File is removed successfully"

statement is executed, otherwise "echo File is not removed" statement is executed (since exist status is non-zero)


### **I/O Redirection and file descriptors**

As you know I/O redirectors are used to send output of command to file or to read input from file.
Consider following example

- $ cat > myf

This is my file

^D (press CTRL + D to save file)

Above command send output of cat command to myf file

- $ cal

Above command prints calendar on screen, but if you wish to store this calendar to file then give
command

- $ cal > mycal

The cal command send output to mycal file. This is called output redirection.

The sort command takes input from keyboard and then sorts the number and prints (send) output to screen itself. If you wish to take input from file (for sort command) give command as follows:

$ cat > nos

10

-20

11

2

^D

$ sort < nos

-20

2

10

11

First you created the file nos using cat command, then nos file given as input to sort command which prints sorted numbers. This is called input redirection.

In Linux (And in C programming Language) your keyboard, screen etc are all treated as files. Following are name of such files

|Standard File|File Descriptors number|Use|Example|
|---|---|---|---|
|stdin|0|as Standard input|Keyboard|
|stdout|1|as Standard output|Screen|
|stderr|2|as Standard error|Screen|



By default in Linux every program has three files associated with it, (when we start our program these three files are automatically opened by your shell). The use of first two files (i.e. stdin and stdout) , are already seen by us. The last file stderr (numbered as 2) is used by our program to print error on screen. You can redirect the output from a file descriptor directly to file with 
following syntax

Syntax:

- file-descriptor-number>filename
    
Examples: (Assume the file bad_file_name111 does not exists)

- $ rm bad_file_name111

- rm: cannot remove `bad_file_name111': No such file or directory

Above command gives error as output, since you don't have file. Now if we try to redirect this
error-output to file, it can not be send (redirect) to file, try as follows:

- $ rm bad_file_name111 > er

Still it prints output on stderr as rm: cannot remove `bad_file_name111': No such file or directory, And if you see er file as $ cat er , this file is empty, since output is send to error device and you can not redirect it to copy this error-output to your file 'er'. To overcome this problem you have to use following

command:

- $ rm bad_file_name111 2>er

Note that no space are allowed between 2 and >, The 2>er directs the standard error output to file. 2 number is default number (file descriptors number) of stderr file.

Write a shell script as follows:

![Screen Shot 2021-02-09 at 11.29.32 AM.png]({{site.baseurl}}/Screen Shot 2021-02-09 at 11.29.32 AM.png)

Run it as follows:

![Screen Shot 2021-02-09 at 11.30.43 AM.png]({{site.baseurl}}/Screen Shot 2021-02-09 at 11.30.43 AM.png)

For first sample run , our script prints error message indicating that you have not given two number.

For second sample run, you have redirected output of script to file er1, since it's error we have to show it to user, It means we have to print our error message on stderr not on stdout. To overcome this problem

replace above echo statements as follows

echo "Error : Number are not supplied" 1>&2

echo "Usage : $0 number1 number2" 1>&2

Now if you run it as follows:

- $ ./demoscr > er1

Error : Number are not supplied

- Usage : ./demoscr number1 number2

It will print error message on stderr and not on stdout. The 1>&2 at the end of echo statement, directs the standard output (stdout) to standard error (stderr) device.


### **Functions**

Syntax:

	function-name ( )
	{
		command1
		command2
		.....
		...
		commandN
		return
	}	
    
Where function-name is name of you function, that executes series of commands. A return statement will terminate the function. 

Example:

Type SayHello() at $ prompt as follows

	$ SayHello()
	{
	echo "Hello $LOGNAME, Have nice computing"
	return
	}

To execute this SayHello() function just type it name as follows:

	$ SayHello

	Hello ec2-user, Have nice computing.
    
This way you can call function. Note that after restarting your computer you will loss this 

SayHello()

function, since its created for current session only. To overcome this problem and to add you own
function to automate some of the day today life task, add your function to /etc/bashrc file. To add function to this file you must logon as root. Following is the sample /etc/bashrc file with today() function, which is used to print formatted date. First logon as root or if you already logon with your name (your login is not root), and want to move to root account, then you can type following command , when asked for password type root (administrators) password.


Open file /etc/bashrc using vi and goto the end of file (by pressing shift+G) and type the today()
function:


![Screen Shot 2021-02-10 at 4.36.54 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 4.36.54 PM.png)


Save the file and exit it.

To run function first completely logout by typing exit at the $ prompt (Or press CTRL + D, Note you may have to type exit (CTRL +D) twice if you login to root account by using su command) ,then login and type $ today , this way today() is available to all user in your system, If you want to add particular function to particular user then open .bashrc file in users home directory.

![Screen Shot 2021-02-10 at 4.39.05 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 4.39.05 PM.png)


**Why to write function?**

- Saves lot of time.
- Avoids rewriting of same code again and again
- Program is easier to write.
- Program maintains is very easy.

### **User Interface**


Good program/shell script must interact with users. You can accomplish this as follows:

(1) Use command line arguments (args) to script when you want interaction i.e. pass command line args to script as : $ ./sutil.sh foo 4, where foo & 4 are command line args passed to shell script sutil.sh.

(2) Use statement like echo and read to read input into variable from the prompt. For e.g. Write script as:

![Screen Shot 2021-02-10 at 4.44.32 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 4.44.32 PM.png)


Save it and run as:

![Screen Shot 2021-02-10 at 4.45.13 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 4.45.13 PM.png)


Even you can create menus to interact with user, first show menu option, then ask user to choose menu item, and take appropriate action according to selected menu item, this technique is show in following script:

![Screen Shot 2021-02-10 at 4.52.13 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 4.52.13 PM.png)


Above all statement explained in following table:

![Screen Shot 2021-02-10 at 7.29.18 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.29.18 PM.png)

**Start infinite loop, this loop will only break if you select 5 ( i.e. Exit/Stop menu item) as your menu
choice.**

![Screen Shot 2021-02-10 at 7.29.52 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.29.52 PM.png)

**Start loop and Clear the screen, each and every time.**

![Screen Shot 2021-02-10 at 7.30.56 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.30.56 PM.png)

**Show menu on screen with menu items, Ask user to enter menu item number, and Read menu item number from user.**

![Screen Shot 2021-02-10 at 7.31.56 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.31.56 PM.png)

**Read menu item number from user, Take appropriate action according to selected menu item, If menu item is not between 1 - 5, then show error and ask user to input number between 1-5 again and Stop loop , if menu item number is 5 ( i.e. Exit/Stop)**


User interface usually includes, menus, different type of boxes like info box, message box, Input box etc. In Linux shell (i.e. bash) there is no built-in facility available to create such user interface, But there is one utility supplied with Red Hat Linux version 6.0 called dialog, which is used to create different type of boxes like info box, message box, menu box, Input box etc. Next section shows you how to use dialog utility.

### **trap command**

Consider following script example:

![Screen Shot 2021-02-10 at 5.33.16 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 5.33.16 PM.png)

Now if you press ctrl + c , while running this script, script get terminated. The ctrl + c here work as signal, When such signal occurs its send to all process currently running in your system. Now consider following shell script:

![Screen Shot 2021-02-10 at 5.43.20 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 5.43.20 PM.png)

Run it

It first ask you main database file where all appointment of the day is stored, if no such database file found, file is created, after that it open one temporary file in /tmp directory, and puts today's date in that file. Then one infinite loop begins, which ask appointment title, time and remark, if this information is correct its written to temporary file, After that, script asks user , whether he/she wants to add next appointment record, if yes then next record is added , otherwise all records are copied from temporary file to database file and then loop will be terminated. You can view your database file by using cat command. Now problem is that while running this script, if you press CTRL + C, your shell script gets terminated and temporary file are left in /tmp directory. For e.g. try it as follows:

- $./testsign1

After given database file name and after adding at least one appointment record to temporary file press CTRL+C, Our script get terminated, and it left temporary file in /tmp directory, you can check this by giving command as follows

- $ ls /tmp/input*

Our script needs to detect such signal (event) when occurs; To achieve this we have to first detect Signal using trap command.

Syntax:

	trap {commands} {signal number list}
    
|Signal Number|When occurs|
|-	|-	|
|0|shell exit|
|1|hangup|
|2|interrupt (CTRL+C)|
|3|quit|
|9|kill (cannot be caught)|


To catch signal in above script, put trap statement before calling Take_input1 function as trap del_file 2 ., Here trap command called del_file() when 2 number interrupt ( i.e. CTRL+C ) occurs. 

Open above script in editor and modify it so that at the end it will look like as follows:

![Screen Shot 2021-02-10 at 6.07.45 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 6.07.45 PM.png)

![Screen Shot 2021-02-10 at 6.08.07 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 6.08.07 PM.png)

Run the script as:

- $ ./testsign1

After giving database file name and after giving appointment title press CTRL+C, Here we have already captured this CTRL + C signal (interrupt), so first our function del_file() is called, in which it gives message as "* * * CTRL + C Trap Occurs (removing temporary file)* * * " and then it remove our temporary file and then exit with exit status 1. Now check /tmp directory as follows

- $ ls /tmp/input*

Now Shell will report no such temporary file exit.

### **The shift Command**

The shift command moves the current values stored in the positional parameters (command line args) to the left one position. For example, if the values of the current positional parameters are:

- $1 = -f $2 = foo $3 = bar

and you executed the shift command the resulting positional parameters would be as follows:

- $1 = foo $2 = bar

Write the following shell script

![Screen Shot 2021-02-10 at 6.27.31 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 6.27.31 PM.png)

You can also move the positional parameters over more than one place by specifying a number with the shift command. The following command would shift the positional parameters two places:

shift 2

- But where to use shift command?

You can use shift command to parse the command line (args) option. For example consider the following simple shell script:

![Screen Shot 2021-02-10 at 6.29.29 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 6.29.29 PM.png)

Run the script as follows:

![Screen Shot 2021-02-10 at 6.31.12 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 6.31.12 PM.png)

Above script is run in variety of ways. First three sample run converts the number 500 ( -n 500 ) to respectively 1F4 (hexadecimal number i.e. -b 16), 764 (octal number i.e. -b 16) , 111110100 (binary number i.e. -b 16). It use -n and -b as command line option which means:

-b {base-system i.e. 16,8,2 to which -n number to convert}

-n {Number to convert to -b base-system}

Fourth and fifth sample run produce the error "Program ./convert does not recognize option -v". This is because these two (-v & -t) are not the valid command line option.

Sixth sample run produced output "500 Decimal number = 13310 in Unknown number system(base=4)".
Because the base system 4 is unknown to our script.

Last sample run shows that command line options can given different ways i.e. you can use it as follows:

- $ ./convert -n 500 -b 16

Instead of

- $ ./convert -b 16 -n 500

All the shell script command can be explained as follows:

![Screen Shot 2021-02-10 at 7.22.13 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.22.13 PM.png)


**Begins the while loop; continue the while loop as long as script reads the all command line option.**

![Screen Shot 2021-02-10 at 7.22.27 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.22.27 PM.png)


**Now start to parse the command line (args) option using if command our script understands the -b and -n options only all other option are invalid. If option is -b then stores the value of
second command line arg to variable ob (i.e. if arg is -b 16 then store the 16 to ob).**

![Screen Shot 2021-02-10 at 7.22.43 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.22.43 PM.png)


**For easy understanding of conversion we store the respective number base systems corresponding string to basesystem variable. If base system is 16 then store the Hex to basesystem and so on. This is done using case statement.**

![Screen Shot 2021-02-10 at 7.22.55 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.22.55 PM.png)


**Once first two command line options (args) are read, we need next two command line option (args). shift 2 will moves the current values stored in the positional parameters (command
line args) to the left two position.**


![Screen Shot 2021-02-10 at 7.23.11 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.23.11 PM.png)


**Now check the next command line option and if its -n option then stores the value of second
command line arg to variable num (i.e. if arg is -n 500 then store the 500 to num) and shift 2 will moves the current values stored in the positional parameters (command line args)
to the left two position.**

![Screen Shot 2021-02-10 at 7.23.26 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.23.26 PM.png)


**If command line option is not -n or -b then print the error "Program ./convert does not recognize option xx" on screen and terminates the shell script using exit 1 statement.**

![Screen Shot 2021-02-10 at 7.24.09 PM.png]({{site.baseurl}}/Screen Shot 2021-02-10 at 7.24.09 PM.png)


**End of loop as we read all the valid command line option/args and  Now convert the given number to given number system using BC Show the converted number on screen.**

As you can see shift command can use to parse the command line (args) option. This is useful if you have limited number of command line option. If command line options are too many then this approach works slowly as well as complex to write and maintained. You need to use another shell built in command - getopts. Next section shows the use of getopts command. You still need the shift command in conjunction with getopts for other shell scripting work.


### **getopts command**

This command is used to check valid command line argument are passed to script. Usually used in while
loop.

Syntax:

		getopts {optstring} {variable1}
        
getopts is used by shell to parse command line argument.

As defined in man pages:

"optstring contains the option letters to be recognized; if a letter is followed by a colon, the option is
expected to have an argument, which should be separated from it by white space. Each time it is invoked,
getopts places the next option in the shell variable variable1, When an option requires an argument,
getopts places that argument into the variable OPTARG. On errors getopts diagnostic messages are
printed when illegal options or missing option arguments are encountered. If an illegal option is seen,
getopts places ? into variable1."

Example:

We have script called ani which has syntax as ani -n -a -s -w -d

Options: These are optional argument

-n name of animal

-a age of animal

-s sex of animal

-w weight of animal

-d demo values (if any of the above options are used their values are not taken)

Above ani script is as follows:


![Screen Shot 2021-02-11 at 10.53.52 AM.png]({{site.baseurl}}/Screen Shot 2021-02-11 at 10.53.52 AM.png)


![Screen Shot 2021-02-11 at 10.54.17 AM.png]({{site.baseurl}}/Screen Shot 2021-02-11 at 10.54.17 AM.png)


Save it and run as follows

Because of getopts, we can pass command line argument in different style. Following are invalid
options for ani script.

![Screen Shot 2021-02-11 at 11.00.00 AM.png]({{site.baseurl}}/Screen Shot 2021-02-11 at 11.00.00 AM.png)


![Screen Shot 2021-02-11 at 11.00.23 AM.png]({{site.baseurl}}/Screen Shot 2021-02-11 at 11.00.23 AM.png)


-c is not one of the valid options.


# **Chapter 5: Essential Utilities for Power User.**

### **Prepering for Quick Tour of essential utilities**

**Cut Utility**

General Syntax of cut utility:

	cut -f{field number} {file-name}


Use of Cut utility: Selecting portion of a file.

For this part of tutorial create sname and smark data files as follows (Using text editor of your choice) Note Each data block is separated from the other by TAB character i.e. while creating the file if you type 11 then press "tab" key, and then write Vivek (as shown in following files):


![Screen Shot 2021-02-17 at 9.21.19 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.21.19 AM.png)


![Screen Shot 2021-02-17 at 9.21.40 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.21.40 AM.png)


Suppose from sname file you wish to print name of student on-screen, then from shell (Your command
prompt i.e. $).

cut utility cuts out selected data from sname file. To select Sr.no. field from sname give command as follows:

![Screen Shot 2021-02-17 at 9.22.19 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.22.19 AM.png)

- cut: Name of cut utility
- -f1: Using (-f) option, you are specifying the extraction field number. (In this example
its 1 i.e. first field).
- sname: File which is used by cut utility and which is use as input for cut utility.


You can redirect output of cut utility as follows:

![Screen Shot 2021-02-17 at 9.25.26 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.25.26 AM.png)

**Paste Utility**

General Syntax of paste utility:

	paste {file1} {file2}

Use of paste utility: Putting lines together.

Now enter following command at shell prompt

![Screen Shot 2021-02-17 at 9.27.33 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.27.33 AM.png)

Paste utility join textual information together. To clear your idea try following command at shell prompt:

![Screen Shot 2021-02-17 at 9.28.04 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.28.04 AM.png)


Paste utility is useful to put textual information together located in various files.


**Join Utility**

Syntax:
	
    join {file1} {file2}
    
Use of join utility: The join utility joins, lines from separate files.

Now enter following command at shell prompt:

![Screen Shot 2021-02-17 at 9.30.05 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.30.05 AM.png)


Here students names are matched with their appropriate marks. How ? join utility uses the Sr.No. field to join to files. Notice that Sr.No. is the first field in both sname and smark file.


**tr utility**

Syntax:

	tr {pattern-1} {pattern-2}
    
Use of tr utility: To translate range of characters into other range of characters.

![Screen Shot 2021-02-17 at 9.32.54 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.32.54 AM.png)

You can clearly see that each occurrence of character 'N' is replace with '3' and '2' with 'x'. tr utilitytranslate specific characters into other specific characters or range of characters into other ranges.

N -> 3

2 -> x

![Screen Shot 2021-02-17 at 9.34.36 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.34.36 AM.png)


Press CTRL + C to terminate.

Here tr translate range of characters (i.e. small a to z) into other (i.e. to Capital A to Z) ranges.

After typing following paragraph, I came to know my mistake that entire paragraph must be in lowercase characters, how to correct this mistake? (Hint - Use tr utility).

![Screen Shot 2021-02-17 at 9.41.53 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.41.53 AM.png)

![Screen Shot 2021-02-17 at 9.42.06 AM.png]({{site.baseurl}}/Screen Shot 2021-02-17 at 9.42.06 AM.png)





